\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usepackage{pgfgantt}

\date{}

\begin{document}


\begin{titlepage}
\begin{tikzpicture}[remember picture, overlay]
  \draw[line width = 2pt,color=blue] ($(current page.north west) + (2.7cm,-2.7cm)$) rectangle ($(current page.south east) + (-2.7cm,2.7cm)$);
   \draw[line width = 1pt,color=green] ($(current page.north west) + (2.6cm,-2.6cm)$) rectangle ($(current page.south east) + (-2.6cm,2.6cm)$);
\end{tikzpicture}
\vspace{0cm}
\begin{center}
HO CHI MINH CITY UNIVERSITY OF TECHNOLOGY \\
\textbf{FACULTY OF COMPUPTER SCIENCE AND TECHNOLOGY} \\
- - - - - - - - - - - -
\end{center}


\vspace{1cm}
\begin{figure}[h!]
\begin{center}
\includegraphics[width=3.6cm]{hcmut.png}
\end{center}
\end{figure}
\vspace{1cm}



\begin{center}
\begin{tabular}
\multicolumn{\textbf{\Large OPERATING SYSTEM}}\\
\hline
\\
\textbf{{\Large BUILD A SIMULATED OPERATING SYSTEM}} \\


\\
\hline
\end{tabular}
\end{center}

\begin{table}[h]
\begin{tabular}{rrl}
\hspace{5cm} & \textbf{Student}: & NGUYEN Anh Khoa -- 1611617 \\
& & TRINH Thi Thu Thao -- 1613232 \\
& & TRAN Dang Khoi -- 1611660 \\
& & TRAN Quoc Dinh -- 1610721

\end{tabular}
\end{table}
\vspace{-0.2cm}

\begin{table}[h]
\begin{tabular}{rrl}
\hspace{5cm} & \textbf{Class}: & L03 \\
\hspace{5cm} & \textbf{Teacher}: & PHAM Trung Kien \\

\end{tabular}
\end{table}
\vspace{1cm}

\begin{center}
% {\footnotesize Tp. Hồ Chí Minh, Tháng 5/2018}
\end{center}
\end{titlepage}

%Mục lục
\newpage
\thispagestyle{empty}
\tableofcontents
\newpage

\subsection{Introduction}\label{introduction}

In this assignment, student are given a code that simulate the load and
run of processes of an operating system. The code pre-given is
incomplete and students need to implement as a practice.

There are three parts that the student must implement,

\begin{itemize}
\tightlist
\item
  Scheduling
\item
  Memory management
\item
  Overall app
\end{itemize}

Our group will go into details of how to implement the three section
describe above.

\subsection{Scheduling}\label{scheduling}

In this section, we must implement two things, the queue and the
function to get a process.

\subsubsection{Queue}\label{queue}

The queue is given in two files, queue.h as a header and queue.c as
implementation. This part requires us to create a queue of process
control block (PCB) as a priority queue. As the implementation, our
group has create a max heap where the priority of the PCB is used to
level the PCB.

\subsubsection{Get Process}\label{get-process}

The scheduling system is given in two files, sched.h as a header and
sched.c as implementation. We have two global variables, the
ready\_queue, and run\_queue. We also have a mutex, queue\_lock. Our
goal is to implement the missing function,
\texttt{struct\ pcb\_t*\ get\_proc(void)}.

As describe in the assignment, the operating system uses a multilevel
feedback queue, i.e Ready Queue, and Run Queue. The operating system
always take the process from the Ready Queue and put it to Run Queue,
when the Ready Queue is empty and Run Queue is not, the operating system
must put all process in Run Queue back to Ready Queue, and get from
Ready Queue.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ pcb_t* get_proc(}\DataTypeTok{void}\NormalTok{) \{}
        \ControlFlowTok{if}\NormalTok{ (queue_empty())}
                \ControlFlowTok{return}\NormalTok{ NULL;}

\NormalTok{        pthread_mutex_lock(&queue_lock);}
        \ControlFlowTok{if}\NormalTok{ (empty(&ready_queue)) \{}
                \ControlFlowTok{while}\NormalTok{ (!empty(&run_queue)) \{}
                        \KeywordTok{struct}\NormalTok{ pcb_t* temp = dequeue(&run_queue);}
\NormalTok{                        enqueue(&ready_queue, temp);}
\NormalTok{                \}}
\NormalTok{        \}}
\NormalTok{        proc = dequeue(&ready_queue);}
\NormalTok{        pthread_mutex_unlock(&queue_lock);}

        \ControlFlowTok{return}\NormalTok{ proc;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The schedule system is implemented, we run a few test to verify it's
validity. The sample output from the assignment is the exact same with
what we will print when run with the same input.

\subsubsection{Gantt diagram for
scheduling}\label{gantt-diagram-for-scheduling}

\paragraph{sched_0}\label{sched0}

\begin{ganttchart}[vgrid]{0}{23}
    \gantttitlelist{0,...,23}{1} \\
    \ganttbar{P1}{1}{3}
    \ganttbar{}{3}{4}
    \ganttbar{}{9}{10}
    \ganttbar{}{13}{14}
    \ganttbar{}{16}{18}
    \ganttbar{}{18}{20}
    \ganttbar{}{20}{22}
    \ganttbar{}{22}{22} \\
    
    \ganttbar{P2}{5}{6}
    \ganttbar{}{7}{8}
    \ganttbar{}{11}{12}
    \ganttbar{}{15}{15} \\

\end{ganttchart}

\paragraph{sched_1 (part 1)}\label{sched1_1}

\begin{ganttchart}[vgrid]{0}{30}
    \gantttitlelist{0,...,30}{1} \\
    \ganttbar{P1}{1}{3}
    \ganttbar{}{3}{4}
    \ganttbar{}{15}{16}
    \ganttbar{}{23}{24} \\
    
    \ganttbar{P2}{5}{6}
    \ganttbar{P2}{11}{12}
    \ganttbar{}{19}{20}
    \ganttbar{}{27}{28} \\
    
    \ganttbar{P3}{7}{8}
    \ganttbar{}{13}{14}
    \ganttbar{}{21}{22}
    \ganttbar{}{28}{29} \\
    
    \ganttbar{P4}{9}{10}
    \ganttbar{}{17}{18}
    \ganttbar{}{25}{26} \\

\end{ganttchart}

\paragraph{sched_1 (part 2)}\label{sched1_2}

\begin{ganttchart}[vgrid]{0}{16}
    \gantttitlelist{30,...,46}{1} \\
    \ganttbar{P1}{0}{1}
    \ganttbar{}{6}{7}
    \ganttbar{}{12}{13}
    \ganttbar{}{15}{15} \\
    
    \gantttitle{P2-finished}{17} \\
    
    \ganttbar{P3}{4}{5}
    \ganttbar{}{10}{11} \\
    
    \ganttbar{P4}{2}{3}
    \ganttbar{}{8}{9}
    \ganttbar{}{14}{14} \\

\end{ganttchart}

\subsection{Memory}\label{memory}

In this section, we must implement four things, get the page table of a
process given the first level, translate a virtual address to a physical
address, allocate ram for a process, free memory pages from an address.

\subsubsection{How virtual memory works}\label{how-virtual-memory-works}

Before coding, it is good that we look again on how virtual memory
works, in pagination, segmentation and a system using both.

\paragraph{Pagination}\label{pagination}

In the pagination system, we will split the ram into sections, called a
page. When allocating, we will give the process linearly-placed pages,
pages are continuously placed one after another. This implementation
causes an internal-fragmentation, when we allocate more than we really
need. The pages often are very big in size, and giving away a page to a
small program causes the system to waste valuable resources.

\paragraph{Segmentation}\label{segmentation}

In the segmentation, we give a part of the ram pages that may not
continuously placed to the process. The process now will see itself as a
collection of segment, i.e code segment, data segment\ldots{} While this
process solve the internal-fragmentation, it issued another problem,
external-fragmentation, the ram is free but pages are not continuously
aligned, and the system has to map the pages together to make the
process see the memory as one big memory segment.

\paragraph{Combination of both}\label{combination-of-both}

When using the pagination, external-fragmentation is no issued, while
using segmentation solve internal-fragmentation problem in the
pagination method. We combine the two method to create a better memory
management system.

The paging system is used to divide ram, we still give process pages of
ram, but in a different way. When call for allocating a memory, we will
search through ram to look for free-pages. Then we will chain these
pages together to create a segment. In the segment, we will have a table
of indexes of pages in the real ram that is allocated.

\paragraph{Dealing with virtual
memory}\label{dealing-with-virtual-memory}

We must use virtual memory when we use a segment, because the pages
might not continuously aligned. In the combination method, a process has
first a table of segment, and in each segment, we have a table of pages
map to physical pages. This is a two level index table, the common
algorithm to manage the tables are a two index and offset method.

In this assignment, we are given the 20 bit address, the first 5 are
segment index, the second 5 are the page index in the segment and the
last 10 are offset.

We keep the index in the segment table and page table to quickly get the
page, and the physical page index.

\subsubsection{Implementation}\label{implementation}

\paragraph{Get page table}\label{get-page-table}

Given the index of the segment, we can get the page table quickly.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \KeywordTok{struct}\NormalTok{ page_table_t*}
\NormalTok{get_page_table(addr_t index,                    }\CommentTok{// Segment level index}
               \KeywordTok{struct}\NormalTok{ seg_table_t* seg_table) \{ }\CommentTok{// first level table}
        \DataTypeTok{int}\NormalTok{ i;}
        \ControlFlowTok{for}\NormalTok{ (i = }\DecValTok{0}\NormalTok{; i < seg_table->size; i++) \{}
                \ControlFlowTok{if}\NormalTok{ (seg_table->table[i].v_index == index)}
                        \ControlFlowTok{return}\NormalTok{ seg_table->table[i].pages;}
\NormalTok{        \}}
        \ControlFlowTok{return}\NormalTok{ NULL;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\paragraph{Translate}\label{translate}

From the virtual address, we can get the segment index (as first level),
the page index (as second level), and the offset.

Given those we can get the physical index of a page in the page table
where the page index is equal the second-level, and we can get a page
from a segment through the \texttt{get\_page\_table} function above.

Because the physical index is only the index of pages in ram, we can get
the real address by or-ing with the shifted index.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ translate(addr_t virtual_addr,   }\CommentTok{// Given virtual address}
\NormalTok{                     addr_t* physical_addr, }\CommentTok{// Physical address to be returned}
                     \KeywordTok{struct}\NormalTok{ pcb_t* proc) \{ }\CommentTok{// Process uses given virtual address}

        \CommentTok{/* Offset of the virtual address */}
\NormalTok{        addr_t offset = get_offset(virtual_addr);}
        \CommentTok{/* The first layer index */}
\NormalTok{        addr_t first_lv = get_first_lv(virtual_addr);}
        \CommentTok{/* The second layer index */}
\NormalTok{        addr_t second_lv = get_second_lv(virtual_addr);}


        \CommentTok{/* Search in the first level */}
        \KeywordTok{struct}\NormalTok{ page_table_t* page_table = NULL;}
\NormalTok{        page_table = get_page_table(first_lv, proc->seg_table);}
        \ControlFlowTok{if}\NormalTok{ (page_table == NULL) \{}
                \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{        \}}

        \DataTypeTok{int}\NormalTok{ i;}
        \ControlFlowTok{for}\NormalTok{ (i = }\DecValTok{0}\NormalTok{; i < page_table->size; i++) \{}

                \ControlFlowTok{if}\NormalTok{ (page_table->table[i].v_index == second_lv) \{}
\NormalTok{                        *physical_addr =}
\NormalTok{                            (page_table->table[i].p_index << OFFSET_LEN) |}
\NormalTok{                            offset;}

                        \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{                \}}
\NormalTok{        \}}
        \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\paragraph{Allocating}\label{allocating}

The process of allocating can be dived into 6 steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Check for free pages
\item
  Get the correct page-table
\item
  Iterate the list of free pages to edit
\item
  If all pages are mapped, done
\item
  Update the virtual address to map
\item
  Go back step 2
\end{enumerate}

In the steps above, step number 2 is the core. Our group has implement
the get segment to get the segment of the process and from the segment
we can get the pages accordingly to the second level of the virtual
address.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ \{}
\NormalTok{        addr_t v_index;}
        \KeywordTok{struct}\NormalTok{ page_table_t* pages;}
\NormalTok{\} * get_segment(addr_t first_lv, }\KeywordTok{struct}\NormalTok{ pcb_t* proc) \{}
        \CommentTok{// get segment in process}
        \KeywordTok{struct}\NormalTok{ \{}
\NormalTok{                addr_t v_index;}
                \KeywordTok{struct}\NormalTok{ page_table_t* pages;}
\NormalTok{        \}* segment = NULL;}
        \DataTypeTok{int}\NormalTok{ idx = }\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{ (idx = }\DecValTok{0}\NormalTok{; idx < proc->seg_table->size; idx++) \{}
                \CommentTok{// find the seg_table with v_index = first_level}
                \ControlFlowTok{if}\NormalTok{ (first_lv == proc->seg_table->table[idx].v_index)}
                        \ControlFlowTok{break}\NormalTok{;}
\NormalTok{        \}}

        \ControlFlowTok{if}\NormalTok{ (idx == proc->seg_table->size) \{}
\NormalTok{                proc->seg_table->size++;}
\NormalTok{        \}}

\NormalTok{        segment = &(proc->seg_table->table[idx]);}
\NormalTok{        segment->v_index = first_lv;}

        \ControlFlowTok{if}\NormalTok{ (segment->pages == NULL) \{}
\NormalTok{                segment->pages =}
\NormalTok{                    (}\KeywordTok{struct}\NormalTok{ page_table_t*)malloc(}\KeywordTok{sizeof}\NormalTok{(}\KeywordTok{struct}\NormalTok{ page_table_t));}
\NormalTok{        \}}

        \ControlFlowTok{return}\NormalTok{ segment;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And a declaration:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{addr_t page_anchor = ret_mem;}
\NormalTok{addr_t first_lv = get_first_lv(page_anchor);}
\NormalTok{addr_t second_lv = get_second_lv(page_anchor);}
\NormalTok{addr_t new_first_lv = }\DecValTok{0}\NormalTok{;}

\DataTypeTok{const} \DataTypeTok{int}\NormalTok{ max_page = }\DecValTok{1}\NormalTok{ << SEGMENT_LEN;}
\DataTypeTok{int}\NormalTok{* page_size = NULL;}
\KeywordTok{struct}\NormalTok{ \{}
\NormalTok{addr_t v_index;}
\NormalTok{addr_t p_index;}
\NormalTok{\}* page_table = NULL;}

\KeywordTok{struct}\NormalTok{ \{}
\NormalTok{addr_t v_index;}
\KeywordTok{struct}\NormalTok{ page_table_t* pages;}
\NormalTok{\}* segment = NULL;}

\NormalTok{segment = get_segment(first_lv, proc);}
\NormalTok{page_table = segment->pages->table;}
\NormalTok{page_size = &(segment->pages->size);}
\end{Highlighting}
\end{Shaded}

And step 3 to 6:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ mem_page = }\DecValTok{0}\NormalTok{; mem_page < NUM_PAGES; mem_page++) \{}
      \ControlFlowTok{if}\NormalTok{ (_mem_stat[mem_page].proc != }\DecValTok{0}\NormalTok{)}
            \ControlFlowTok{continue}\NormalTok{;}

      \CommentTok{// update _mem_stat}
\NormalTok{      _mem_stat[mem_page].proc = proc->pid;}
\NormalTok{      _mem_stat[mem_page].index = free_space++;}
      \ControlFlowTok{if}\NormalTok{ (free_space != }\DecValTok{1}\NormalTok{)}
\NormalTok{            _mem_stat[prev].next = mem_page;}
      \ControlFlowTok{if}\NormalTok{ (free_space == num_pages)}
\NormalTok{            _mem_stat[mem_page].next = }\DecValTok{-1}\NormalTok{;}
\NormalTok{      prev = mem_page;}

      \CommentTok{// update in page_table}
\NormalTok{      page_table[*page_size].v_index = second_lv;}
\NormalTok{      page_table[*page_size].p_index = mem_page;}
\NormalTok{      (*page_size)++;}

      \ControlFlowTok{if}\NormalTok{ (free_space == num_pages)}
            \ControlFlowTok{break}\NormalTok{;}

      \CommentTok{// move to next page}
\NormalTok{      page_anchor += PAGE_SIZE;}
\NormalTok{      new_first_lv = get_first_lv(page_anchor);}
\NormalTok{      second_lv = get_second_lv(page_anchor);}

      \ControlFlowTok{if}\NormalTok{ (new_first_lv != first_lv) \{}
            \CommentTok{// get a new segment people}
\NormalTok{            first_lv = new_first_lv;}
\NormalTok{            segment = get_segment(first_lv, proc);}
\NormalTok{            page_table = segment->pages->table;}
\NormalTok{            page_size = &(segment->pages->size);}
\NormalTok{      \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The check on step 1 is easy to implement. Check for free pages on ram,
and check for out of bound break pointer.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ free_space = }\DecValTok{0}\NormalTok{;}
\ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < NUM_PAGES; i++) \{}
      \ControlFlowTok{if}\NormalTok{ (_mem_stat[i].proc == }\DecValTok{0}\NormalTok{)}
\NormalTok{            free_space++;}
      \ControlFlowTok{if}\NormalTok{ (free_space == num_pages) \{}
\NormalTok{            mem_avail = }\DecValTok{1}\NormalTok{;}
            \ControlFlowTok{break}\NormalTok{;}
\NormalTok{      \}}
\NormalTok{\}}

\CommentTok{// if break pointer is out of bound}
\ControlFlowTok{if}\NormalTok{ (proc->bp + num_pages * PAGE_SIZE > (}\DecValTok{1}\NormalTok{ << ADDRESS_SIZE)) \{}
\NormalTok{      mem_avail = }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}

\ControlFlowTok{if}\NormalTok{ (!mem_avail) \{}
\NormalTok{      pthread_mutex_unlock(&mem_lock);}
      \ControlFlowTok{return}\NormalTok{ ret_mem;}
\NormalTok{\}}

\CommentTok{// step 2 to 6}
\end{Highlighting}
\end{Shaded}

\paragraph{Free}\label{free}

As the \texttt{\_mem\_stat} table keeps a proc as a process id to
indicate the use status, we can loop to find pages with proc is our pid
and set clear.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ free_mem(addr_t address, }\KeywordTok{struct}\NormalTok{ pcb_t* proc) \{}
\NormalTok{        addr_t physical_addr;}
        \ControlFlowTok{if}\NormalTok{ (translate(address, &physical_addr, proc)) \{}
                \DataTypeTok{int}\NormalTok{ i = physical_addr >> OFFSET_LEN;}
\NormalTok{                pthread_mutex_lock(&mem_lock);}
                \ControlFlowTok{while}\NormalTok{ (i != }\DecValTok{-1}\NormalTok{) \{}
\NormalTok{                        _mem_stat[i].proc = }\DecValTok{0}\NormalTok{;}
\NormalTok{                        i = _mem_stat[i].next;}
\NormalTok{                \}}
\NormalTok{                pthread_mutex_unlock(&mem_lock);}
                \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
                \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{        \}}
        \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Checking}\label{checking}

After all is done, we run the memory check, the result map is identical
so we are heading the right track.

We can see the status of ram after each call to \texttt{alloc} and
\texttt{free}.

\paragraph{m0}\label{m0}

\begin{verbatim}
Ram after free 00400 -> 00000
013: 03400-037ff - PID: 01 (idx 000, nxt: -01)
---
Ram after allocating 1 pages -> 03c00
000: 00000-003ff - PID: 01 (idx 000, nxt: -01)
013: 03400-037ff - PID: 01 (idx 000, nxt: -01)
---
Ram after allocating 4 pages -> 04000
000: 00000-003ff - PID: 01 (idx 000, nxt: -01)
001: 00400-007ff - PID: 01 (idx 000, nxt: 002)
002: 00800-00bff - PID: 01 (idx 001, nxt: 003)
003: 00c00-00fff - PID: 01 (idx 002, nxt: 004)
004: 01000-013ff - PID: 01 (idx 003, nxt: -01)
013: 03400-037ff - PID: 01 (idx 000, nxt: -01)
---
000: 00000-003ff - PID: 01 (idx 000, nxt: -01)
    003e8: 15
001: 00400-007ff - PID: 01 (idx 000, nxt: 002)
002: 00800-00bff - PID: 01 (idx 001, nxt: 003)
003: 00c00-00fff - PID: 01 (idx 002, nxt: 004)
004: 01000-013ff - PID: 01 (idx 003, nxt: -01)
013: 03400-037ff - PID: 01 (idx 000, nxt: -01)
    03414: 66
\end{verbatim}

\paragraph{m1}\label{m1}

\begin{verbatim}
Ram after allocating 13 pages -> 00400
000: 00000-003ff - PID: 01 (idx 000, nxt: 001)
001: 00400-007ff - PID: 01 (idx 001, nxt: 002)
002: 00800-00bff - PID: 01 (idx 002, nxt: 003)
003: 00c00-00fff - PID: 01 (idx 003, nxt: 004)
004: 01000-013ff - PID: 01 (idx 004, nxt: 005)
005: 01400-017ff - PID: 01 (idx 005, nxt: 006)
006: 01800-01bff - PID: 01 (idx 006, nxt: 007)
007: 01c00-01fff - PID: 01 (idx 007, nxt: 008)
008: 02000-023ff - PID: 01 (idx 008, nxt: 009)
009: 02400-027ff - PID: 01 (idx 009, nxt: 010)
010: 02800-02bff - PID: 01 (idx 010, nxt: 011)
011: 02c00-02fff - PID: 01 (idx 011, nxt: 012)
012: 03000-033ff - PID: 01 (idx 012, nxt: -01)
---
Ram after allocating 1 pages -> 03800
000: 00000-003ff - PID: 01 (idx 000, nxt: 001)
001: 00400-007ff - PID: 01 (idx 001, nxt: 002)
002: 00800-00bff - PID: 01 (idx 002, nxt: 003)
003: 00c00-00fff - PID: 01 (idx 003, nxt: 004)
004: 01000-013ff - PID: 01 (idx 004, nxt: 005)
005: 01400-017ff - PID: 01 (idx 005, nxt: 006)
006: 01800-01bff - PID: 01 (idx 006, nxt: 007)
007: 01c00-01fff - PID: 01 (idx 007, nxt: 008)
008: 02000-023ff - PID: 01 (idx 008, nxt: 009)
009: 02400-027ff - PID: 01 (idx 009, nxt: 010)
010: 02800-02bff - PID: 01 (idx 010, nxt: 011)
011: 02c00-02fff - PID: 01 (idx 011, nxt: 012)
012: 03000-033ff - PID: 01 (idx 012, nxt: -01)
013: 03400-037ff - PID: 01 (idx 000, nxt: -01)
---
Ram after free 00400 -> 00000
013: 03400-037ff - PID: 01 (idx 000, nxt: -01)
---
Ram after allocating 1 pages -> 03c00
000: 00000-003ff - PID: 01 (idx 000, nxt: -01)
013: 03400-037ff - PID: 01 (idx 000, nxt: -01)
---
Ram after allocating 4 pages -> 04000
000: 00000-003ff - PID: 01 (idx 000, nxt: -01)
001: 00400-007ff - PID: 01 (idx 000, nxt: 002)
002: 00800-00bff - PID: 01 (idx 001, nxt: 003)
003: 00c00-00fff - PID: 01 (idx 002, nxt: 004)
004: 01000-013ff - PID: 01 (idx 003, nxt: -01)
013: 03400-037ff - PID: 01 (idx 000, nxt: -01)
---
Ram after free 03c00 -> 00000
001: 00400-007ff - PID: 01 (idx 000, nxt: 002)
002: 00800-00bff - PID: 01 (idx 001, nxt: 003)
003: 00c00-00fff - PID: 01 (idx 002, nxt: 004)
004: 01000-013ff - PID: 01 (idx 003, nxt: -01)
013: 03400-037ff - PID: 01 (idx 000, nxt: -01)
---
Ram after free 04000 -> 00400
013: 03400-037ff - PID: 01 (idx 000, nxt: -01)
---
Ram after free 03800 -> 03400
---
\end{verbatim}

\subsection{Overall view}\label{overall-view}

The last task requires us to find critical section in the program and
protect it, I have only found one.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \DataTypeTok{void}\NormalTok{* cpu_routine(}\DataTypeTok{void}\NormalTok{* args) \{}
\NormalTok{    ...}
\NormalTok{        pthread_mutex_lock(&ahihi);}
\NormalTok{    time_left = time_slot;}
\NormalTok{    pthread_mutex_unlock(&ahihi);}
\NormalTok{    ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Conclusion}\label{conclusion}

The operating system we implement uses the following which worth
mentioning.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Multilevel feedback queue
\item
  Priority Queue
\item
  Segmentation with Pagination
\item
  Round Robin
\end{enumerate}

Our operating system simulator using the Multilevel feedback queue to
not make a process to be run multiple times. If there's only one queue,
the process with a higher priority will be run over and over, because
when it is enqueued, it is now the process with highest priority. The
priority queue, keeps a good performance for our operating system.
Segmentation use with Pagination will eliminate both down side about
fragmentation of the two algorithms. Round Robin is effective as there
will be no process use the operating system forever.

\end{document}
